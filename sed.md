# sed

## 目录

<!-- vim-markdown-toc GFM -->

* [简介](#简介)
* [sed工作原理](#sed工作原理)
* [语法](#语法)
    * [OPTIONS](#options)
    * [SCRIPT](#script)
        * [语法](#语法-1)
        * [sed命令总结](#sed命令总结)
        * [s命令](#s命令)

<!-- vim-markdown-toc -->

## 简介
sed是一个流编辑器。流编辑器用于对输入流（文件或来自管道的输入）执行基本文本转换。虽然在某些方面类似于允许脚本编辑的编辑器（例如ed），但sed只需对输入进行一次传递即可工作，因此效率更高。但它sed能够在管道中过滤文本，这是它与其他类型编辑器的特别区别。

默认情况下，sed打印所有已处理的输入（修改和删除除外），-n选项能够抑制输出。sed将输出写入标准输出，如果使用-i选项修改文件不产生任何输出

## sed工作原理
sed维护两个数据缓冲区：活动模式空间和辅助保持空间。两者最初都是空的。

sed通过对每一行输入执行以下循环来进行操作：首先，sed从输入流中读取一行，删除任何尾随换行符，并将其放置在模式空间中。然后执行命令；每个命令都可以有一个与其关联的地址：地址是一种条件代码，只有在执行命令之前验证了条件，才会执行命令。

当到达脚本末尾时，除非-n使用选项时，模式空间的内容将打印到输出流，如果删除了尾随换行符，则将其添加回来。然后针对下一条输入行开始下一个循环。

除非特殊命令（例如'D'）被使用，模式空间在两个循环之间被删除（在处理下一行时会删除模式空间的内容）。另一方面，保持空间在循环之间保留其数据（参见命令'H','H','X','G','G' 在两个缓冲区之间移动数据）。

## 语法
`sed OPTIONS... [SCRIPT] [INPUTFILE...]`

### OPTIONS
```
-n, --quit, --silent
默认情况下，sed在脚本的每个循环结束时打印出模式空间（请参阅工作原理sed）。这些选项禁用此自动打印，并且sed仅在通过命令明确告知时才生成输出p。

-e, --expression=script
将脚本中的命令添加到处理输入时要运行的命令集中。

-f, --file=script-file
将文件script-file中包含的命令 添加到处理输入时要运行的命令集中。

-i[SUFFIX],  --in-place[=SUFFIX]
此选项指定要就地编辑文件。GNUsed通过创建一个临时文件并将输出发送到该文件而不是标准输出来实现此目的。该选项意味着-s。当到达文件末尾时，临时文件将重命名为输出文件的原始名称。扩展名（如果提供）用于在重命名临时文件之前修改旧文件的名称，从而制作备份副本)。遵循以下规则：如果扩展名不包含*，则将其作为后缀附加到当前文件名的末尾；如果扩展名确实包含一个或多个* 字符，则每个星号都将替换为当前文件名。这允许您向备份文件添加前缀，而不是后缀（或除了后缀之外），甚至可以将原始文件的备份副本放入另一个目录中（前提是该目录已存在）。如果未提供扩展名，则将覆盖原始文件而不进行备份。谨慎使用-n和-我：前者禁用自动打印行，后者在没有备份的情况下就地更改文件。如果不小心使用（并且没有明确的p命令），输出文件将为空

-E, -r, --regexp-extended
使用扩展正则表达式而不是基本正则表达式。扩展正则表达式是那些 egrep接受；它们可以更清晰，因为它们通常有更少的反斜杠。从历史上看，这是一个 GNU 扩展，但是-E 扩展已添加到 POSIX 标准 (http://austingroupbugs.net/view.php?id=528)，因此使用-E为了便携性。GNU sed 已接受-E多年来一直作为无证选项，并且 *BSD sed 已接受-E也有很多年了，但是使用的脚本-E可能无法移植到其他旧系统。请参阅扩展正则表达式。

-s, --separate
默认情况下，sed会将命令行上指定的文件视为单个连续的长流。这个 GNUsed 扩展允许用户将它们视为单独的文件：范围地址（例如 '/abc/,/def/') 不允许跨越多个文件，行号相对于每个文件的开头，$指每个文件的最后一行，并且从命令调用的文件R在每个文件的开头回滚

如果命令行上没有给出 -e、-f、--expression 或 --file 选项，则命令行上的第一个非选项参数将被视为要执行的脚本。

如果在处理完上述操作后仍有任何命令行参数，这些参数将被解释为要处理的输入文件的名称。 文件名为 '-' 指的是标准输入流。如果未指定文件名，将处理标准输入。
```

### SCRIPT
一个sed脚本由一个或多个sed命令组成，由一个或多个 -e、-f、--expression 和 --file 选项传入，或者由第一个非选项参数传入（如果使用了零个这些选项）。传入的scripts和script-files会按传入的顺序串联起来依次处理。

#### 语法
`[addr]X[options]`
X表示单个的sed命令，[addr]是可选的行地址。如果[addr]指定，则命令X将仅在匹配的行上执行。 [addr]可以是单个行号、正则表达式或行范围。附加[options]用于某些sed命令。

脚本或脚本文件中的命令可以用分号或换行符分隔，但a、c、i命令由于他们的语法，后面不能跟作为命令分隔符的分号，因此应以换行符终止或放置在脚本或脚本文件的末尾

#### sed命令总结
GNU sed 支持以下命令。有些是标准 POSIX 命令，有些是 GNU 扩展。每个命令的详细信息和示例位于以下部分。（助记符）显示在括号中。
```
a\
text
在行后 附加文本。

a text
在行后 附加文本（替代语法）。

b label
无条件分支到标签。标签可以被省略，在这种情况下开始下一个循环。

c\
text
用文本替换（change）行。

c text
用文本替换（change）行（替代语法）。

d
删除模式空间；立即开始下一个周期。

D
如果模式空间包含换行符，则删除模式空间中直到第一个换行符的文本，并使用生成的模式空间重新启动循环，而不读取新的输入行。

如果模式空间不包含换行符，则启动正常的新循环，就像d发出命令一样。

e
执行在模式空间中找到的命令并用输出替换模式空间；尾随换行符被抑制。

e command
执行命令并将其输出发送到输出流。该命令可以跨多行运行，除了最后一行以外，所有行都以反斜杠结尾。

F
(filename) 打印当前输入文件的文件名（尾随换行符）。

g
将模式空间的内容替换为保留空间的内容。

G
将换行符附加到模式空间的内容，然后将保留空间的内容附加到模式空间的内容。

h
(hold) 用模式空间的内容替换保持空间的内容。

H
将换行符附加到保留空间的内容，然后将模式空间的内容附加到保留空间的内容。

i\
text
在行前 插入文本。

i text
在行前插入文本（替代语法）。

l
以明确的形式打印模式空间。

n
（下一步）如果未禁用自动打印，则打印模式空间，然后无论如何，用下一行输入替换模式空间。如果没有更多输入，则sed退出而不处理任何更多命令。

N
将换行符添加到模式空间，然后将下一行输入附加到模式空间。如果没有更多输入，则sed退出而不处理任何更多命令。

p
打印模式空间。

P
打印模式空间，直到第一个 <newline>。

q[exit-code]
（退出）退出sed而不处理任何其他命令或输入。

Q[exit-code]
(quit) 该命令与 相同q，但不会打印模式空间的内容。与 一样q，它提供了向调用者返回退出代码的能力。

s/regexp/replacement/[flags]
（substitute）将正则表达式与模式空间的内容进行匹配。如果找到，则将匹配的字符串替换为 replacement。

t label
（测试）仅当自读取最后一个输入行或采用条件分支以来已成功 替换时，才分支到标签。s标签可以被省略，在这种情况下开始下一个循环。

T label
（测试）仅当自上次读取输入行或采用条件分支以来没有成功 替换时，才分支到标签。s标签可以被省略，在这种情况下开始下一个循环。

v [version]
（版本）此命令不执行任何操作，但sed如果不支持 GNUsed扩展，或者请求的版本不可用，则会失败。

w filename
将模式空间写入filename。

W filename
将模式空间部分写入给定文件名，直到第一个换行符

x
交换保持空间和模式空间的内容。

y/src/dst/
将模式空间中与任何source-chars匹配的任何字符与dest-chars中的相应字符进行音译。

z
(zap) 该命令清空模式空间的内容。

#
注释，直到下一个换行符。

{ cmd ; cmd ... }
将多个命令组合在一起。

=
打印当前输入行号（带有尾随换行符）。

: label
指定分支命令（b、t、T）的标签位置。
```

#### s命令
s 命令（作为替代命令）可能是 sed 中最重要的命令，并且有很多不同的选项。 s 命令的语法是“s/regexp/replacement/[flags]”。

它的基本概念很简单：s 命令尝试将模式空间与提供的正则表达式 regexp 进行匹配；如果匹配成功，则模式空间中匹配的部分将被替换。

replacement可以包含 \n（n 是 1 到 9 之间的数字，包括 1 和 9）引用，它指的是包含在第 n 个 \( 及其匹配的 \) 之间的匹配部分。此外，替换可以包含未转义的 & 字符，它们引用模式空间的整个匹配部分。

/ 字符可以统一替换为任何给定 s 命令中的任何其他单个字符。仅当 / 字符（或替代它的任何其他字符）前面有 \ 字符时，它才可以出现在正则表达式或替换中。

最后，作为 GNU sed 扩展，您可以包含由反斜杠和字母 L、l、U、u 或 E 之一组成的特殊序列。含义如下：
```
\L
将替换内容转为小写，直到找到 \Uor ，\E

\l
将下一个字符转为小写，

\U
将替换内容转为大写，直到找到 \Lor ，\E

\u
将下一个字符转为大写，

\E
\L停止由或启动的大小写转换\U。
```

s 命令后面可以跟零个或多个以下flags：
```
g
将替换应用于regexp的所有匹配项，而不仅仅是第一个。

number
仅替换regexp的第th 个匹配项。

s指挥 互动 注意：POSIX标准没有指定混合使用g和数字修饰符时会发生什么，并且目前跨实现还没有广泛商定的含义sed。对于 GNU 来说sed，交互被定义为：忽略第th号之前的匹配，然后匹配并替换从第th号开始的所有匹配。

p
如果进行了替换，则打印新的模式空间。

注意：当同时指定p和e选项时，两者的相对顺序会产生非常不同的结果。一般来说，ep（评估然后打印）是您想要的，但相反的操作对于调试可能很有用。因此，当前版本的 GNU特别解释了before 和 after 选项 sed的存在，在计算之前和之后打印模式空间，而一般来说，命令的标志仅显示一次其效果。尽管有记录，此行为可能会在未来版本中发生变化。 pes

w filename
如果进行了替换，则将结果写入指定文件。作为 GNUsed扩展，支持两个特殊的文件名值：/dev/标准错误，将结果写入标准错误，并且/dev/标准输出，写入标准输出。3

e
该命令允许将 shell 命令的输入通过管道传送到模式空间。如果进行了替换，则执行在模式空间中找到的命令，并用其输出替换模式空间。尾随换行符被抑制；如果要执行的命令包含NUL字符，则结果未定义。这是一个 GNUsed扩展。

I
i
I正则表达式匹配的修饰符是一个 GNU 扩展，它以不区分大小写的方式 sed匹配正则表达式。

M
m
M正则表达式匹配的修饰符是一个 GNU扩展sed ，它指示 GNU以多行sed模式匹配正则表达式。修饰符使和分别匹配（除了正常行为之外）换行符后面的空字符串和换行符之前的空字符串。有一些特殊的字符序列（和）始终与缓冲区的开头或结尾匹配。此外，在多行模式下，句点字符与换行符不匹配。 ^$\`\'
```
